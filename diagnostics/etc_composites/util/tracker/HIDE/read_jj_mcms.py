import sys,os
import defines

class Read_MCMS:
    """This Class contains the basic logic for reading and manipulating
    data files from the MCMS project. It uses object orientation to maximize
    the reuse of code and minimize the amount of code in general.

    Options/Arguments:

    Returns:

    Examples:

    Notes: This should work with any standard installation of python version
    2.4 or greater. I have tested it on Apple OS-X (10.5/10.6), Ubuntu
    (8.04/9.04) and RedHat Enterprise 4.0 Linux distributions.

    Author: Mike Bauer  <mbauer@giss.nasa.gov>

    Log:
        2008/07  MB - File created.
        2008/09  MB - Finished initial code base.
        2008/09  MB - Multiple bug fixes.
        2008/10  MB - Added input checks, docstring.
        2008/10  MB - Bug fix in fetch_center: skip saving -777 and -888
                      if place or time check enforced and nothing has
                      passed.
        2009/11  MB - Updated to v4, removed need for model def file.
    """

    def __init__(self,**kwargs):
        """This is where the default values are set with the option to alter
      then upon instantiation.
        """        
        # Name: template
        # Purpose: Full path to template file to tell read what to do.
        # Default: empty - raises error
        if kwargs.has_key('template'):
            self.template = kwargs['template']
            # Import values as module (namespace local not self).
            try:
                print "Importing '%s' ... " % (self.template),
                # Remove .py extension
                self.template = os.path.splitext(self.template)[0]
                cmd = 'from %s import *' % (self.template)
                exec(cmd)
                print "Done"
                # Import template data into instance
                ignore_these = ('cmd','kwargs','self')
                for value in dir():
                    if value not in ignore_these:
                        cmd = 'self.%s = %s' % (value,value)
                        exec(cmd)
                self.parse_template()
                # Conflict check
                if self.detail_tracks and self.as_tracks:
                    warning = "WARNING: detail_tracks and as_tracks cannot"
                    warning = warning + " both be non-empty ... Aborting."
                    sys.exit(warning)
            except IOError:
                warning = "Oops! %s failed to open.  Try again..."
                sys.exit(warning % (self.template))

            ## Import model defs    
            #if kwargs.has_key('model'):
            #    if kwargs['model'] in ["nra","nra2"]:
            #        if kwargs.has_key('maxID'):
            #            # Use provided values already imported above.
            #            pass
            #         else:
            #            # For the NCAR/NCEP Reanalysis 1 and 2 these values are provided
            #            # and nothing need be done.
            #            self.tropical_start = tropical_start
            #            self.tropical_end = tropical_end 
            #            self.maxID = maxID
            #            self.land_gridids = land_gridids
            #    else:
            #        if kwargs.has_key('maxID'):
            #            # Use provided values already imported above.
            #            pass
            #        else:
            #            warning = "Oops! no model defs provided! Try again..."
            #            sys.exit(warning)
            # else:
            #    warning = "Oops! no model defs provided! Try again..."
            #    sys.exit(warning)

        else:
            # Use provided values
            self.model = kwargs['model']
            self.in_file = kwargs['in_file']
            self.out_file = kwargs['out_file']
            self.just_center_table = kwargs['just_center_table']
            self.detail_tracks = kwargs['detail_tracks']
            self.as_tracks = kwargs['as_tracks']
            self.start_time = kwargs['start_time']
            self.end_time = kwargs['end_time']
            self.places = kwargs['places']
            self.include_atts = kwargs['include_atts']
            self.include_stormy = kwargs['include_stormy']
            self.just_centers = kwargs['just_centers']
            self.save_output = kwargs['save_output']
            self.overwrite = kwargs['overwrite']
            self.parse_template()
            
        # JIMMY VERBOSE
        '''print "Jimmy reading template"
        print model
        print self.model
        print self.detail_tracks
        print kwargs.has_key('model')
        print kwargs.has_key('template')
        print kwargs
        '''
        # Import model defs   
        if kwargs.has_key('model'):
            if kwargs['model'] in ["nra","nra2"]:
                if kwargs.has_key('maxID'):
                    # Use provided values already imported above.
                    pass
                else:
                    # For the NCAR/NCEP Reanalysis 1 and 2 these values are provided
                    # and nothing need be done.
                    self.provision_nra()
            else:
                if kwargs.has_key('maxID'):
                    # Use provided values already imported above.
                    pass
                else:
                    warning = "Oops! no model defs provided! Try again..."
                    sys.exit(warning)
        else:
            warning = "Oops! no model defs provided! Try again..."
            sys.exit(warning)

        self.mm2season = { 1  : ("DJF","NDJFMA"),
                           2  : ("DJF","NDJFMA"),
                           3  : ("MAM","NDJFMA"),
                           4  : ("MAM","NDJFMA"),
                           5  : ("MAM","MJJASO"),
                           6  : ("JJA","MJJASO"),
                           7  : ("JJA","MJJASO"),
                           8  : ("JJA","MJJASO"),
                           9  : ("SON","MJJASO"),
                           10 : ("SON","MJJASO"),
                           11 : ("SON","NDJFMA"),
                           12 : ("DJF","NDJFMA")}
        if kwargs.has_key('verbose'):
            # if present print details
            self.verbose = True
        else:
            self.verbose = False

    def provision_nra(self):
        """Defaults for NRA 1 and 2 circa 2009"""
        self.tropical_start = 3456
        self.tropical_end = 7055
        self.maxID = 144*73
        self.land_gridids = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
                30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
                44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
                58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,
                72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,
                86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,
                100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110,
                111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
                122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132,
                133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
                144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154,
                155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165,
                166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176,
                177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187,
                188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198,
                199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
                210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220,
                221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231,
                232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242,
                243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253,
                254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264,
                265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275,
                276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286,
                287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297,
                298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308,
                309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319,
                320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330,
                331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341,
                342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352,
                353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363,
                364, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381,
                382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392,
                393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403,
                404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414,
                415, 416, 417, 418, 419, 420, 421, 422, 423, 424, 425,
                426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436,
                437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447,
                448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458,
                459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469,
                470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480,
                481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491,
                492, 493, 494, 495, 496, 497, 498, 516, 517, 518, 519,
                520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530,
                531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541,
                542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552,
                553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563,
                564, 565, 566, 567, 568, 569, 570, 571, 572, 573, 574,
                575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585,
                586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 596,
                597, 598, 599, 600, 601, 602, 603, 604, 605, 606, 607,
                608, 609, 610, 611, 612, 613, 614, 615, 616, 617, 618,
                619, 620, 621, 622, 623, 624, 625, 626, 627, 628, 629,
                630, 631, 632, 633, 634, 635, 636, 637, 638, 639, 640,
                658, 659, 660, 661, 662, 663, 664, 665, 666, 667, 668,
                669, 670, 671, 672, 673, 674, 675, 676, 677, 678, 679,
                680, 681, 682, 683, 684, 685, 686, 687, 700, 701, 706,
                707, 708, 709, 710, 711, 712, 713, 714, 715, 716, 717,
                718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728,
                729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739,
                740, 741, 742, 743, 744, 745, 746, 747, 748, 749, 750,
                751, 752, 753, 754, 755, 756, 757, 758, 759, 760, 761,
                762, 763, 764, 765, 766, 767, 768, 769, 770, 771, 772,
                773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783,
                784, 785, 802, 805, 806, 807, 808, 809, 810, 811, 812,
                813, 814, 815, 816, 817, 818, 819, 820, 821, 822, 823,
                824, 825, 826, 827, 828, 829, 830, 831, 832, 833, 834,
                835, 836, 851, 852, 853, 854, 855, 856, 857, 858, 859,
                860, 861, 862, 863, 864, 865, 866, 867, 868, 869, 870,
                871, 872, 873, 874, 875, 876, 877, 878, 879, 880, 881,
                882, 883, 884, 885, 886, 887, 888, 889, 890, 891, 892,
                893, 894, 895, 896, 897, 898, 899, 900, 901, 902, 903,
                904, 905, 906, 907, 908, 909, 910, 911, 912, 913, 914,
                915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925,
                926, 927, 928, 929, 953, 954, 955, 956, 957, 958, 959,
                960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 970,
                971, 972, 973, 974, 975, 976, 977, 978, 979, 980, 981,
                982, 983, 999, 1000, 1001, 1002, 1003, 1004, 1005, 1006,
                1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016,
                1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026,
                1027, 1028, 1029, 1030, 1031, 1032, 1033, 1034, 1035, 1036,
                1037, 1038, 1039, 1040, 1041, 1042, 1043, 1044, 1045, 1046,
                1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056,
                1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066,
                1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1113,
                1114, 1115, 1116, 1117, 1124, 1125, 1126, 1127, 1146, 1147,
                1148, 1149, 1150, 1151, 1165, 1166, 1168, 1169, 1170, 1171,
                1172, 1173, 1174, 1175, 1176, 1177, 1178, 1179, 1183, 1184,
                1185, 1186, 1187, 1188, 1189, 1190, 1191, 1192, 1193, 1194,
                1195, 1196, 1197, 1198, 1199, 1200, 1201, 1202, 1203, 1204,
                1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214,
                1215, 1216, 1268, 1269, 1270, 1271, 1315, 1316, 1317, 1318,
                1319, 1320, 1321, 1329, 1330, 1331, 1332, 1333, 1334, 1335,
                1336, 1337, 1338, 1339, 1340, 1341, 1342, 1343, 1344, 1345,
                1346, 1347, 1348, 1349, 1350, 1351, 1352, 1353, 1354, 1413,
                1414, 2132, 2133, 2275, 2276, 2419, 2420, 2563, 2564, 2565,
                2660, 2707, 2708, 2709, 2805, 2851, 2852, 2853, 2854, 2950,
                2995, 2996, 2997, 2998, 2999, 3081, 3082, 3083, 3139, 3140,
                3141, 3142, 3143, 3144, 3223, 3224, 3225, 3226, 3227, 3228,
                3284, 3285, 3286, 3287, 3288, 3289, 3320, 3321, 3322, 3323,
                3359, 3360, 3361, 3362, 3366, 3367, 3368, 3369, 3370, 3371,
                3372, 3428, 3429, 3430, 3431, 3432, 3433, 3434, 3464, 3465,
                3466, 3467, 3468, 3503, 3504, 3505, 3506, 3507, 3508, 3509,
                3510, 3511, 3512, 3513, 3514, 3515, 3516, 3517, 3572, 3573,
                3574, 3575, 3576, 3577, 3578, 3579, 3607, 3608, 3609, 3610,
                3611, 3612, 3613, 3646, 3647, 3648, 3649, 3650, 3651, 3652,
                3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3716,
                3717, 3718, 3719, 3720, 3721, 3722, 3723, 3724, 3750, 3751,
                3752, 3753, 3754, 3755, 3756, 3757, 3790, 3791, 3792, 3793,
                3794, 3795, 3796, 3797, 3798, 3799, 3800, 3801, 3802, 3803,
                3804, 3860, 3861, 3862, 3863, 3864, 3865, 3866, 3867, 3868,
                3869, 3894, 3895, 3896, 3897, 3898, 3899, 3900, 3901, 3906,
                3907, 3934, 3935, 3936, 3937, 3938, 3939, 3940, 3941, 3942,
                3943, 3944, 3945, 3946, 3947, 4004, 4005, 4006, 4007, 4008,
                4009, 4010, 4011, 4012, 4013, 4014, 4037, 4038, 4039, 4040,
                4041, 4042, 4043, 4044, 4045, 4050, 4051, 4080, 4081, 4082,
                4083, 4084, 4085, 4086, 4087, 4088, 4089, 4090, 4091, 4148,
                4149, 4150, 4151, 4152, 4153, 4154, 4155, 4156, 4157, 4158,
                4159, 4181, 4182, 4183, 4184, 4185, 4186, 4187, 4188, 4189,
                4190, 4194, 4195, 4226, 4227, 4228, 4229, 4230, 4231, 4232,
                4233, 4234, 4292, 4293, 4294, 4295, 4296, 4297, 4298, 4299,
                4300, 4301, 4302, 4303, 4304, 4325, 4326, 4327, 4328, 4329,
                4330, 4331, 4332, 4333, 4334, 4335, 4336, 4339, 4372, 4373,
                4374, 4377, 4434, 4435, 4436, 4437, 4438, 4439, 4440, 4441,
                4442, 4443, 4444, 4445, 4446, 4447, 4448, 4470, 4471, 4472,
                4473, 4474, 4475, 4476, 4477, 4478, 4479, 4480, 4517, 4518,
                4521, 4578, 4579, 4580, 4581, 4582, 4583, 4584, 4585, 4586,
                4587, 4588, 4589, 4590, 4591, 4592, 4614, 4615, 4616, 4617,
                4618, 4619, 4620, 4621, 4622, 4623, 4624, 4721, 4722, 4723,
                4724, 4725, 4726, 4727, 4728, 4729, 4730, 4731, 4732, 4733,
                4734, 4735, 4736, 4737, 4758, 4759, 4760, 4761, 4762, 4763,
                4764, 4765, 4766, 4767, 4808, 4809, 4810, 4865, 4866, 4867,
                4868, 4869, 4870, 4871, 4872, 4873, 4874, 4875, 4876, 4877,
                4878, 4879, 4880, 4881, 4882, 4901, 4902, 4903, 4904, 4905,
                4906, 4907, 4908, 4909, 4910, 4911, 4938, 4951, 4952, 4953,
                4954, 5008, 5009, 5010, 5011, 5012, 5013, 5014, 5015, 5016,
                5017, 5018, 5019, 5020, 5021, 5022, 5023, 5024, 5025, 5044,
                5045, 5046, 5047, 5048, 5049, 5050, 5051, 5052, 5053, 5054,
                5055, 5056, 5081, 5082, 5085, 5086, 5088, 5093, 5095, 5096,
                5153, 5154, 5155, 5156, 5157, 5158, 5159, 5160, 5161, 5162,
                5163, 5164, 5165, 5166, 5188, 5189, 5190, 5191, 5192, 5193,
                5194, 5195, 5196, 5197, 5198, 5199, 5200, 5201, 5224, 5225,
                5228, 5229, 5230, 5231, 5297, 5298, 5299, 5300, 5301, 5302,
                5303, 5304, 5305, 5306, 5307, 5308, 5333, 5334, 5335, 5336,
                5337, 5338, 5339, 5340, 5341, 5342, 5343, 5344, 5345, 5346,
                5368, 5369, 5373, 5374, 5375, 5441, 5442, 5443, 5444, 5445,
                5446, 5447, 5448, 5449, 5450, 5451, 5475, 5476, 5477, 5478,
                5479, 5480, 5481, 5482, 5483, 5484, 5485, 5486, 5487, 5488,
                5489, 5490, 5491, 5511, 5513, 5519, 5585, 5586, 5587, 5588,
                5589, 5590, 5591, 5592, 5593, 5594, 5595, 5613, 5616, 5617,
                5618, 5619, 5620, 5621, 5622, 5623, 5624, 5625, 5626, 5627,
                5628, 5629, 5630, 5631, 5632, 5633, 5634, 5635, 5648, 5666,
                5729, 5730, 5731, 5732, 5733, 5734, 5735, 5736, 5756, 5757,
                5758, 5759, 5760, 5761, 5762, 5763, 5764, 5765, 5766, 5767,
                5768, 5769, 5770, 5771, 5772, 5773, 5774, 5775, 5776, 5777,
                5778, 5779, 5780, 5791, 5802, 5874, 5875, 5876, 5877, 5878,
                5879, 5899, 5900, 5901, 5902, 5903, 5904, 5905, 5906, 5907,
                5908, 5909, 5910, 5911, 5912, 5913, 5914, 5915, 5916, 5917,
                5918, 5919, 5920, 5921, 5935, 5944, 5945, 5946, 5947, 6014,
                6042, 6043, 6044, 6045, 6046, 6047, 6048, 6049, 6050, 6051,
                6052, 6053, 6054, 6055, 6056, 6057, 6058, 6059, 6060, 6061,
                6062, 6063, 6064, 6065, 6066, 6067, 6078, 6079, 6080, 6088,
                6089, 6090, 6091, 6156, 6157, 6158, 6186, 6187, 6188, 6189,
                6190, 6191, 6192, 6193, 6194, 6195, 6196, 6197, 6198, 6199,
                6200, 6201, 6202, 6203, 6204, 6205, 6206, 6207, 6209, 6210,
                6211, 6212, 6213, 6222, 6223, 6224, 6225, 6230, 6231, 6232,
                6233, 6234, 6296, 6297, 6298, 6299, 6300, 6330, 6331, 6332,
                6333, 6334, 6335, 6336, 6337, 6338, 6339, 6340, 6341, 6342,
                6343, 6344, 6345, 6346, 6347, 6348, 6349, 6350, 6353, 6354,
                6355, 6356, 6357, 6358, 6365, 6366, 6367, 6368, 6369, 6370,
                6374, 6375, 6376, 6377, 6378, 6438, 6439, 6440, 6441, 6444,
                6474, 6475, 6476, 6477, 6478, 6479, 6480, 6481, 6482, 6483,
                6484, 6485, 6486, 6487, 6488, 6489, 6490, 6491, 6492, 6493,
                6494, 6496, 6497, 6498, 6499, 6500, 6501, 6502, 6503, 6508,
                6509, 6510, 6511, 6512, 6513, 6514, 6515, 6516, 6517, 6518,
                6519, 6520, 6521, 6522, 6523, 6524, 6525, 6582, 6583, 6584,
                6618, 6619, 6620, 6621, 6622, 6623, 6624, 6625, 6626, 6627,
                6628, 6629, 6630, 6631, 6632, 6633, 6634, 6635, 6636, 6637,
                6639, 6640, 6641, 6642, 6643, 6644, 6647, 6648, 6649, 6650,
                6651, 6652, 6653, 6654, 6655, 6656, 6657, 6658, 6659, 6660,
                6661, 6662, 6663, 6664, 6665, 6666, 6667, 6668, 6669, 6670,
                6671, 6725, 6726, 6727, 6728, 6729, 6763, 6764, 6765, 6766,
                6767, 6768, 6769, 6770, 6771, 6772, 6773, 6774, 6775, 6776,
                6777, 6778, 6779, 6780, 6781, 6782, 6783, 6784, 6785, 6786,
                6787, 6789, 6790, 6791, 6792, 6793, 6794, 6795, 6796, 6797,
                6798, 6799, 6800, 6801, 6802, 6803, 6804, 6805, 6806, 6807,
                6808, 6809, 6810, 6811, 6812, 6813, 6814, 6815, 6816, 6867,
                6868, 6869, 6870, 6871, 6872, 6873, 6879, 6880, 6908, 6909,
                6910, 6911, 6912, 6913, 6914, 6915, 6916, 6917, 6918, 6919,
                6920, 6921, 6922, 6923, 6924, 6925, 6926, 6927, 6928, 6929,
                6930, 6931, 6932, 6933, 6934, 6935, 6936, 6937, 6938, 6939,
                6940, 6941, 6942, 6943, 6944, 6945, 6946, 6947, 6948, 6949,
                6950, 6951, 6952, 6953, 6954, 6955, 6956, 6957, 6958, 6959,
                6960, 7010, 7011, 7012, 7013, 7014, 7015, 7016, 7017, 7018,
                7023, 7052, 7053, 7054, 7055, 7056, 7057, 7058, 7059, 7060,
                7061, 7070, 7071, 7072, 7073, 7074, 7075, 7076, 7077, 7078,
                7079, 7080, 7081, 7082, 7083, 7084, 7085, 7086, 7087, 7088,
                7089, 7090, 7091, 7092, 7093, 7094, 7095, 7096, 7097, 7098,
                7099, 7100, 7101, 7102, 7103, 7104, 7154, 7155, 7156, 7157,
                7158, 7159, 7160, 7161, 7162, 7163, 7164, 7165, 7166, 7167,
                7197, 7198, 7199, 7200, 7201, 7202, 7203, 7204, 7215, 7216,
                7217, 7218, 7219, 7220, 7221, 7222, 7223, 7224, 7225, 7226,
                7227, 7228, 7229, 7230, 7231, 7232, 7233, 7234, 7235, 7236,
                7237, 7238, 7239, 7240, 7241, 7242, 7243, 7244, 7245, 7246,
                7247, 7251, 7253, 7254, 7255, 7296, 7297, 7298, 7299, 7300,
                7301, 7302, 7303, 7304, 7305, 7306, 7307, 7308, 7309, 7310,
                7311, 7312, 7313, 7342, 7353, 7355, 7356, 7357, 7358, 7359,
                7360, 7361, 7362, 7363, 7366, 7367, 7368, 7369, 7370, 7371,
                7372, 7373, 7374, 7375, 7376, 7377, 7378, 7379, 7380, 7381,
                7382, 7383, 7384, 7385, 7386, 7387, 7388, 7389, 7390, 7391,
                7392, 7395, 7400, 7439, 7440, 7441, 7442, 7443, 7444, 7445,
                7446, 7447, 7448, 7449, 7450, 7451, 7452, 7453, 7454, 7455,
                7456, 7457, 7485, 7486, 7487, 7496, 7497, 7499, 7500, 7501,
                7502, 7503, 7504, 7505, 7506, 7507, 7510, 7511, 7512, 7513,
                7514, 7515, 7516, 7517, 7518, 7519, 7520, 7521, 7522, 7523,
                7524, 7525, 7526, 7527, 7528, 7529, 7530, 7531, 7532, 7533,
                7534, 7535, 7536, 7538, 7539, 7544, 7583, 7584, 7585, 7586,
                7587, 7588, 7589, 7590, 7591, 7592, 7593, 7594, 7595, 7596,
                7597, 7598, 7599, 7600, 7601, 7602, 7629, 7630, 7631, 7632,
                7637, 7640, 7641, 7642, 7643, 7648, 7649, 7650, 7651, 7653,
                7654, 7655, 7656, 7657, 7658, 7659, 7660, 7661, 7662, 7663,
                7664, 7665, 7666, 7667, 7668, 7669, 7670, 7671, 7672, 7673,
                7674, 7675, 7676, 7677, 7678, 7679, 7680, 7681, 7682, 7683,
                7684, 7689, 7727, 7728, 7729, 7730, 7731, 7732, 7733, 7734,
                7735, 7736, 7737, 7738, 7739, 7740, 7741, 7742, 7743, 7744,
                7745, 7746, 7747, 7773, 7774, 7775, 7776, 7777, 7778, 7779,
                7780, 7781, 7782, 7783, 7784, 7785, 7786, 7787, 7792, 7793,
                7794, 7795, 7797, 7798, 7799, 7800, 7801, 7802, 7803, 7804,
                7805, 7806, 7807, 7808, 7809, 7810, 7811, 7812, 7813, 7814,
                7815, 7816, 7817, 7818, 7819, 7820, 7821, 7822, 7823, 7824,
                7825, 7826, 7827, 7828, 7829, 7830, 7833, 7871, 7872, 7873,
                7874, 7875, 7876, 7877, 7878, 7879, 7880, 7881, 7882, 7883,
                7884, 7885, 7886, 7887, 7888, 7889, 7890, 7891, 7892, 7893,
                7894, 7920, 7921, 7922, 7923, 7924, 7925, 7926, 7927, 7928,
                7929, 7930, 7931, 7932, 7933, 7934, 7935, 7936, 7937, 7938,
                7939, 7940, 7941, 7942, 7943, 7944, 7945, 7946, 7947, 7948,
                7949, 7950, 7951, 7952, 7953, 7954, 7955, 7956, 7957, 7958,
                7959, 7960, 7961, 7962, 7963, 7964, 7965, 7966, 7967, 7968,
                7969, 7970, 7971, 7972, 7973, 7974, 7975, 8015, 8016, 8017,
                8018, 8019, 8020, 8021, 8022, 8023, 8024, 8025, 8026, 8027,
                8028, 8029, 8030, 8031, 8032, 8033, 8034, 8035, 8036, 8037,
                8038, 8065, 8066, 8067, 8068, 8069, 8070, 8071, 8072, 8073,
                8074, 8075, 8076, 8077, 8078, 8079, 8080, 8081, 8082, 8083,
                8084, 8085, 8086, 8087, 8088, 8089, 8090, 8091, 8092, 8093,
                8094, 8095, 8096, 8097, 8098, 8099, 8100, 8101, 8102, 8103,
                8104, 8105, 8106, 8107, 8108, 8109, 8110, 8111, 8112, 8113,
                8114, 8115, 8116, 8117, 8118, 8119, 8121, 8158, 8159, 8160,
                8161, 8162, 8163, 8164, 8165, 8166, 8167, 8168, 8169, 8170,
                8171, 8172, 8173, 8174, 8175, 8176, 8177, 8178, 8179, 8180,
                8181, 8182, 8183, 8208, 8210, 8211, 8212, 8213, 8214, 8215,
                8216, 8217, 8218, 8219, 8220, 8221, 8222, 8223, 8224, 8225,
                8226, 8227, 8228, 8229, 8230, 8231, 8232, 8233, 8234, 8235,
                8236, 8237, 8238, 8239, 8240, 8241, 8242, 8243, 8244, 8245,
                8246, 8247, 8248, 8249, 8250, 8251, 8252, 8253, 8254, 8255,
                8256, 8257, 8258, 8259, 8260, 8261, 8262, 8263, 8264, 8265,
                8271, 8301, 8302, 8303, 8304, 8305, 8306, 8307, 8308, 8309,
                8310, 8311, 8312, 8313, 8314, 8315, 8316, 8317, 8318, 8319,
                8321, 8322, 8323, 8324, 8325, 8326, 8327, 8328, 8329, 8349,
                8351, 8356, 8357, 8359, 8360, 8361, 8362, 8363, 8364, 8365,
                8366, 8367, 8368, 8369, 8370, 8371, 8372, 8373, 8374, 8375,
                8376, 8377, 8378, 8379, 8380, 8381, 8382, 8383, 8384, 8385,
                8386, 8387, 8388, 8389, 8390, 8391, 8392, 8393, 8394, 8395,
                8396, 8397, 8398, 8399, 8400, 8401, 8402, 8403, 8404, 8405,
                8406, 8407, 8415, 8416, 8444, 8445, 8446, 8447, 8448, 8449,
                8450, 8451, 8452, 8453, 8454, 8455, 8456, 8457, 8458, 8459,
                8460, 8461, 8462, 8463, 8465, 8466, 8467, 8468, 8469, 8470,
                8471, 8472, 8493, 8495, 8501, 8502, 8506, 8507, 8508, 8509,
                8510, 8511, 8512, 8513, 8514, 8515, 8516, 8517, 8518, 8519,
                8520, 8521, 8522, 8523, 8524, 8525, 8526, 8527, 8528, 8529,
                8530, 8531, 8532, 8533, 8534, 8535, 8536, 8537, 8538, 8539,
                8540, 8541, 8542, 8543, 8544, 8545, 8546, 8547, 8548, 8549,
                8550, 8551, 8552, 8560, 8577, 8578, 8586, 8587, 8588, 8589,
                8590, 8591, 8592, 8593, 8594, 8595, 8596, 8597, 8598, 8599,
                8600, 8601, 8602, 8603, 8610, 8611, 8612, 8613, 8614, 8615,
                8638, 8643, 8644, 8645, 8646, 8647, 8650, 8651, 8652, 8653,
                8654, 8655, 8656, 8657, 8658, 8659, 8660, 8661, 8662, 8663,
                8664, 8665, 8666, 8667, 8668, 8669, 8670, 8671, 8672, 8673,
                8674, 8675, 8676, 8677, 8678, 8679, 8680, 8681, 8682, 8683,
                8684, 8685, 8686, 8687, 8688, 8689, 8690, 8691, 8692, 8693,
                8694, 8695, 8696, 8697, 8698, 8699, 8700, 8701, 8705, 8720,
                8721, 8722, 8724, 8728, 8729, 8730, 8731, 8732, 8733, 8734,
                8735, 8736, 8737, 8738, 8739, 8740, 8741, 8742, 8743, 8744,
                8745, 8746, 8753, 8754, 8755, 8787, 8788, 8789, 8790, 8791,
                8793, 8794, 8795, 8796, 8797, 8798, 8799, 8800, 8801, 8802,
                8803, 8804, 8805, 8806, 8807, 8808, 8809, 8810, 8811, 8812,
                8813, 8814, 8815, 8816, 8817, 8818, 8819, 8820, 8821, 8822,
                8823, 8824, 8825, 8826, 8827, 8828, 8829, 8830, 8831, 8832,
                8833, 8834, 8835, 8836, 8837, 8838, 8839, 8840, 8841, 8842,
                8843, 8844, 8845, 8846, 8847, 8848, 8849, 8850, 8851, 8852,
                8853, 8854, 8862, 8863, 8864, 8865, 8866, 8867, 8868, 8869,
                8870, 8871, 8872, 8873, 8874, 8875, 8876, 8877, 8878, 8879,
                8880, 8881, 8882, 8883, 8884, 8885, 8886, 8887, 8888, 8889,
                8890, 8891, 8898, 8899, 8908, 8909, 8910, 8911, 8933, 8934,
                8935, 8936, 8937, 8938, 8939, 8940, 8941, 8942, 8944, 8945,
                8946, 8947, 8948, 8949, 8950, 8951, 8952, 8953, 8954, 8955,
                8956, 8957, 8958, 8959, 8960, 8961, 8962, 8963, 8964, 8965,
                8966, 8967, 8968, 8969, 8970, 8971, 8972, 8973, 8974, 8975,
                8976, 8977, 8978, 8979, 8980, 8981, 8982, 8983, 8984, 8985,
                8986, 8987, 8988, 8989, 8990, 8991, 8992, 8993, 8994, 8995,
                8996, 8997, 8998, 8999, 9000, 9001, 9002, 9003, 9006, 9007,
                9008, 9009, 9010, 9011, 9012, 9013, 9014, 9015, 9016, 9017,
                9018, 9019, 9020, 9021, 9022, 9023, 9025, 9026, 9027, 9028,
                9029, 9030, 9031, 9032, 9033, 9034, 9035, 9036, 9038, 9043,
                9044, 9045, 9051, 9052, 9053, 9054, 9055, 9056, 9064, 9065,
                9066, 9078, 9079, 9080, 9081, 9082, 9083, 9084, 9085, 9086,
                9087, 9088, 9090, 9092, 9093, 9094, 9095, 9096, 9097, 9098,
                9099, 9100, 9102, 9103, 9104, 9105, 9106, 9107, 9108, 9109,
                9110, 9111, 9112, 9113, 9114, 9115, 9116, 9117, 9118, 9119,
                9120, 9121, 9122, 9123, 9124, 9125, 9126, 9127, 9128, 9129,
                9130, 9131, 9132, 9133, 9134, 9135, 9136, 9137, 9138, 9139,
                9140, 9141, 9142, 9143, 9144, 9145, 9151, 9152, 9153, 9154,
                9155, 9156, 9157, 9158, 9159, 9160, 9161, 9162, 9163, 9164,
                9165, 9166, 9167, 9168, 9169, 9170, 9171, 9172, 9173, 9174,
                9175, 9176, 9177, 9178, 9179, 9180, 9181, 9182, 9183, 9187,
                9188, 9189, 9190, 9195, 9196, 9197, 9198, 9199, 9200, 9201,
                9202, 9224, 9225, 9226, 9227, 9228, 9241, 9244, 9246, 9247,
                9248, 9249, 9250, 9251, 9252, 9253, 9254, 9255, 9256, 9257,
                9258, 9259, 9260, 9261, 9262, 9263, 9264, 9265, 9266, 9267,
                9268, 9269, 9270, 9271, 9272, 9273, 9274, 9275, 9276, 9277,
                9278, 9279, 9282, 9285, 9286, 9296, 9297, 9298, 9299, 9300,
                9301, 9302, 9303, 9308, 9309, 9311, 9314, 9315, 9316, 9317,
                9318, 9322, 9323, 9326, 9327, 9330, 9331, 9332, 9340, 9341,
                9342, 9343, 9344, 9345, 9346, 9347, 9348, 9349, 9350, 9382,
                9393, 9394, 9395, 9396, 9397, 9398, 9399, 9400, 9401, 9402,
                9403, 9404, 9405, 9406, 9407, 9408, 9409, 9410, 9411, 9455,
                9456, 9457, 9458, 9461, 9465, 9466, 9467, 9469, 9470, 9471,
                9482, 9483, 9484, 9485, 9486, 9487, 9488, 9489, 9490, 9491,
                9492, 9493, 9494, 9495, 9527, 9528, 9540, 9541, 9542, 9543,
                9544, 9545, 9546, 9547, 9548, 9549, 9560, 9602, 9603, 9605,
                9608, 9611, 9612, 9613, 9614, 9615, 9626, 9627, 9628, 9629,
                9630, 9631, 9632, 9633, 9634, 9635, 9636, 9637, 9638, 9639,
                9655, 9690, 9757, 9758, 9759, 9760, 9761, 9765, 9766, 9767,
                9768, 9769, 9770, 9771, 9772, 9773, 9774, 9775, 9776, 9777,
                9778, 9779, 9780, 9781, 9782, 9783, 9784, 9798, 9799, 9800,
                9830, 9831, 9899, 9900, 9901, 9902, 9903, 9904, 9905, 9906,
                9909, 9910, 9911, 9912, 9913, 9914, 9915, 9916, 9917, 9918,
                9919, 9920, 9921, 9922, 9923, 9924, 9925, 9926, 9927, 9928,
                10048, 10049, 10050, 10051, 10052, 10062, 10063, 10064,
                10065, 10066, 10067, 10068, 10069]

    def parse_template(self):
        """Parse template file."""

        (self.start_year,self.start_month,self.start_day,self.start_hour,
         self.start_season) = self.start_time.split()

        (self.end_year,self.end_month,self.end_day,self.end_hour,
         self.end_season) = self.end_time.split()

    def check_time(self):
        """See if any time related checks needed"""

        self.time_filter = ['HH','DD','MM','YYYY']

        # Default ensures all time related criteria ignored
        self.time_check = [-1,-1,-1,-1,-1,10000,10000,10000,10000,10000]

        # Update time_check
        if self.start_year != "YYYY":
            self.time_check[0] = int(self.start_year)
        if self.start_month != "MM":
            self.time_check[1] = int(self.start_month)
        if self.start_day != "DD":
            self.time_check[2] = int(self.start_day)
        if self.start_hour != "HH":
            self.time_check[3] = int(self.start_hour)
        if self.start_season != "SEASON":
            self.time_check[4] = self.start_season
            # Warn SEASON can't be used concurrently with other time limits.
            lead = [x for x in self.time_check[:4] if x > 0]
            if lead:
                warning = "SEASON can't be used concurrently with other time"
                warning = warning + " limits.  Aborting."
                sys.exit(warning)

        if self.end_year != "YYYY":
            self.time_check[5] = int(self.end_year)
        if self.end_month != "MM":
            self.time_check[6] = int(self.end_month)
        if self.end_day != "DD":
            self.time_check[7] = int(self.end_day)
        if self.end_hour != "HH":
            self.time_check[8] = int(self.end_hour)
            # Warn HH has to be the same for start and end
            if self.end_hour != self.start_hour:
                warning = "HH must be the same for start and end. Aborting."
                sys.exit(warning)
        if self.end_season != "SEASON":
            self.time_check[9] = self.end_season
            # Warn SEASON can't be used concurrently with other time limits.
            if self.start_season != self.end_season:
                warning = "SEASON start and end mismatched"
                warning = warning + " limits.  Aborting."
                sys.exit(warning)

        # See if any thing to check at all
        lead = [x for x in self.time_check[:5] if x > 0]
        tails = [x for x in self.time_check[5:] if x != 10000]
        if not lead and not tails:
            self.time_check = []

    def check_place(self):
        """See if any place related checks needed"""

        if self.places[0] == "GLOBAL":
            # Default ensures all place related criteria ignored
            self.place_check = []
        elif self.places[0] == "NH":
            # Include only centers from the Northern Hemisphere.
            self.place_check = range(self.tropical_end,self.maxID+1)
        elif self.places[0] == "SH":
            # Include only centers from the Southern Hemisphere.
            self.place_check = range(0,self.tropical_start+1)
        elif self.places[0] == "LAND":
            self.place_check = self.land_gridids
        elif self.places[0] == "SEA":
            self.place_check = [x for x in range(self.maxID)
                                if x not in self.land_gridids]
        else:
            # Include only centers from GridID
            self.place_check = [int(x) for x in self.places]

    def start_IO(self):
        """
        Open files for reading and writing.
        """

        # Open file for read
        try:
            read_file = open(self.in_file,"r")
        except IOError:
            sys.exit("The '%s' does not exist.\nStopping" % (self.in_file))

        if self.save_output:
            # Open output file for write
            if not self.out_file:
                # Create out_file from in_file
                try:
                    self.out_file = self.in_file.replace(".txt","_new.txt")
                    if os.path.exists(self.out_file) and not self.overwrite:
                        warning = "WARNING out_file: %s exists"
                        sys.exit(warning % (self.out_file))
                    write_file = open(self.out_file,"w")
                except IOError:
                    warning = "Cannot create file '%s'.\nStopping"
                    sys.exit(warning % (self.out_file))
            else:
                # Open out_file as provided
                if os.path.exists(self.out_file) and not self.overwrite:
                    warning = "WARNING out_file: %s exists"
                    sys.exit(warning % (self.out_file))
                try:
                    write_file = open(self.out_file,"w")
                except IOError:
                    warning = "Cannot create file '%s'.\nStopping"
                    sys.exit(warning % (self.out_file))
            out_file = self.out_file
        else:
            # Don't open a file
            write_file = 'Saving to memory.'
            out_file = write_file

        if self.verbose:
            print "Reading: '%s'\nWriting: '%s'" % (self.in_file,out_file)

        return read_file,write_file

    def fill_tracks(self):
        """Read in tracks database and populate a tracks dictionary"""

        # Open file for read
        try:
            read_file = open(self.as_tracks,"r")
        except IOError:
            warning = "The file '%s' does not exist" % (self.as_tracks)
            warning = warning + " ... Aborting"
            sys.exit(warning)

        self.sorted_tracks = {}
        for line in read_file:
            entry = line.split()
            usi = entry[0]
            self.sorted_tracks[usi] = [x for x in entry if x != usi]
        read_file.close()

    def fetch_centers(self):
        """Read each line of read_file and return information."""

        # Create holding dictionary if not writing to file.
        if not self.save_output:
            self.center_holder = {} # key by UCI
            self.problematic = {} # key by JD
            self.stormy = {} # key by JD

        # Create holding dictionary
        if self.detail_tracks:
            self.save_output = False
            self.sorted_tracks = {} # key by USI

        # Deal with as_tracks
        if self.as_tracks:
            # Read tracks dbase and fill sorted_tracks.
            self.save_output_original = self.save_output
            self.save_output = False
            self.fill_tracks()
            self.track_holder = {}

        # Start file I/O
        read_file,write_file = self.start_IO()

        exit_early = 0
        started = 0

        # Read one line at a time and process
        for line in read_file:
            too_early = 0

            # Process line
            fnc = self.strip_read(line)

            if self.as_tracks:
                # Need to store whole of record in memory to test
                if fnc[0] == 0:
                    if self.track_holder.has_key(fnc[1]['USI']):
                        # Append to existing track
                        old = self.track_holder[fnc[1]['USI']]
                        old.append(line)
                        self.track_holder[fnc[1]['USI']] = old
                    else:
                        # Create a new track
                        self.track_holder[fnc[1]['USI']] = [line]
                # time_check and places screening delayed
                continue

            # See if a center or empty center
            if fnc[0] == 0 or fnc[0] == -999:

                # See if passes extra search criteria
                if self.time_check:
                    # See if Season screen
                    if self.time_check[4] != -1:
                        test = self.mm2season[fnc[1]['MM']]
                        if self.time_check[4] not in test:
                            # Get another
                            continue
                    else:
                        # See if pass start/end requirements
                        bot = 4
                        top = 9
                        for tf in self.time_filter:
                            bot -= 1
                            top -= 1
                            if self.time_check[bot] > fnc[1][tf]:
                                # Read another line until reach start
                                too_early = 1
                                break
                            elif fnc[1][tf] > self.time_check[top]:
                                # Passed end
                                exit_early = 1
                                # Only stops time_filter loop
                                break
                        if too_early:
                            continue
                        if exit_early:
                            # Stop reading altoghter
                            break

                if self.place_check:
                    # Add center
                    screen = [fnc[1]['GridID']]

                    if self.include_atts and fnc[3]:
                        screen.extend(fnc[3])

                    if self.include_stormy:
                        # Allow 'stormy' grids into place check to do this you
                        # need to pre-populate self.stormy_uci.
                        if fnc[1]['UCI'] in self.stormy_uci.keys():
                            screen.extend(self.stormy_uci[fnc[1]['UCI']])

                    # Check for intersection of place_passed and fnc[3]
                    place_passed = [x for x in screen if x in self.place_check]
                    if not place_passed:
                        # Read another line
                        continue

                # Store most recently read julian date
                jd = fnc[1]['JD']

            # If I haven't started saving yet, pass on saving stormy or problematic
            # lines as these are uncheckable for time or place.
            if not started:
                if self.time_check or self.place_check:
                    if fnc[0] == -888 or fnc[0] == -777:
                        continue
            started = 1

            # This center passed the time and place screens
            if self.just_center_table:

                if fnc[0] == 0 or fnc[0] == -999:

#                     lon = fnc[1]['Lon']*0.01
#                     if lon > 180.0:
#                         lon = lon - 360.0
#                     lat = 90.0 - (fnc[1]['CoLat']*0.01)
#                     tmp = ("%(YYYY)d %(MM)d %(DD)d %(HH)d")

                    if self.save_output:
                        # Save just center info file
                        write_file.write(tmp % fnc[1] +
                                         " %.2f %.2f\n" % (lon,lat))
                    else:

                        if self.detail_tracks:
                            if fnc[0] == 0:
                                if fnc[1]['USI'] == "00000000000000000000":
                                    warning = "WARNING USI suggests non-tracking data!"
                                    warning = warning + " Aborting detail_tracks."
                                    sys.exit(warning)
                                if self.sorted_tracks.has_key(fnc[1]['USI']):
                                    # Append to existing track
                                    old = self.sorted_tracks[fnc[1]['USI']]
                                    old.append(fnc[1]['UCI'])
                                    self.sorted_tracks[fnc[1]['USI']] = old
                                else:
                                    # Create a new track
                                    self.sorted_tracks[fnc[1]['USI']] = [fnc[1]['UCI']]
                            # Skip the rest and get another line
                            continue

                        # Need to pass what wanted so don't have to tweak this for
                        # different uses.
                        # Save to a dictionary/memory
# #                         tmp = [fnc[1]['YYYY'],fnc[1]['MM'],fnc[1]['DD'],
# #                                fnc[1]['HH'],lon,lat]]

#                         tmp = [fnc[1]['YYYY'],fnc[1]['MM'],fnc[1]['DD'],
# #                               fnc[1]['HH'],fnc[1]['JD'],lat,lon,fnc[1]['GridID'],
#                                fnc[1]['HH'],fnc[1]['JD'],fnc[1]['CoLat'],fnc[1]['Lon'],fnc[1]['GridID'],
#                                fnc[1]['GridSLP'],fnc[1]['RegSLP'],fnc[1]['GridLAP'],
#                                fnc[1]['Flags'], fnc[1]['Intensity'], fnc[1][ 'Disimularity']]

                        # Use with check when using centers or tracking output pre-att.
                        tmp = [fnc[1]['YYYY'],fnc[1]['MM'],fnc[1]['DD'],
                               fnc[1]['HH'],fnc[1]['JD'],fnc[1]['CoLat'],fnc[1]['Lon'],fnc[1]['GridID'],
                               fnc[1]['GridSLP'],fnc[1]['RegSLP'],fnc[1]['GridLAP'],
                               fnc[1]['Flags'], fnc[1]['Intensity'], fnc[1]['Disimularity'],
                               fnc[1]['UCI'],fnc[1]['USI']]

                        self.center_holder[fnc[1]['UCI']] = tmp


            else:

                if self.detail_tracks:
                    if fnc[0] == 0 or fnc[0] == -999:

                        if fnc[1]['USI'] == "00000000000000000000":
                            warning = "WARNING USI suggests non-tracking data!"
                            warning = warning + " Aborting detail_tracks."
                            sys.exit(warning)
                        if self.sorted_tracks.has_key(fnc[1]['USI']):
                            # Append to existing track
                            old = self.sorted_tracks[fnc[1]['USI']]
                            old.append(fnc[1]['UCI'])
                            self.sorted_tracks[fnc[1]['USI']] = old
                        else:
                            # Create a new track
                            self.sorted_tracks[fnc[1]['USI']] = [fnc[1]['UCI']]
                    # Skip the rest and get another line
                    continue

                if self.save_output:
                    # Save everything to file
                    write_file.write(line)
                else:
                    if fnc[0] == 0:
                        # Return basic center
                        tmp = [fnc[1]['YYYY'],fnc[1]['MM'],fnc[1]['DD'],
                               fnc[1]['HH'],fnc[1]['JD'],fnc[1]['CoLat'],
                               fnc[1]['Lon'],fnc[1]['GridID'],fnc[1]['GridSLP'],
                               fnc[1]['RegSLP'],fnc[1]['GridLAP'],
                               fnc[1]['Flags'],fnc[1]['Intensity'],
                               fnc[1]['Disimularity'],fnc[1]['UCI'],
                               fnc[1]['USI'],fnc[2]['NGrids'],fnc[2]['Area'],
                               fnc[2]['Depth'],fnc[2]['NearestCenterDist'],
                               fnc[2]['NearestCenterAngle'],
                               fnc[2]['MinOuterEdgeDist'],
                               fnc[2]['MaxOuterEdgeDist'],
                               fnc[2]['AveOuterEdgeDist'],[x for x in fnc[3]]]
                        self.center_holder[fnc[1]['UCI']] = tmp
                    elif fnc[0] == -999:
                        # Return empty center
                        tmp = [fnc[1]['YYYY'],fnc[1]['MM'],fnc[1]['DD'],
                               fnc[1]['HH'],fnc[1]['JD'],fnc[1]['CoLat'],
                               fnc[1]['Lon'],fnc[1]['GridID'],fnc[1]['GridSLP'],
                               fnc[1]['RegSLP'],fnc[1]['GridLAP'],
                               fnc[1]['Flags'],fnc[1]['Intensity'],
                               fnc[1]['Disimularity'],fnc[1]['UCI'],
                               fnc[1]['USI']]
                        self.center_holder[fnc[1]['UCI']] = tmp
                    elif(fnc[0] == -888):
                        # Return near_stormy line for further processing
                        self.stormy[jd] = [fnc[1],fnc[2],fnc[3],fnc[4],fnc[5]]
                    elif(fnc[0] == -777):
                        # Return problematic gridids
                        self.problematic[jd] = fnc[1]
        read_file.close()
        if self.save_output:
            write_file.close()

    def fetch_stormy(self):
        """Read each line of read_file and return stormy grids."""

        # Open file for read
        try:
            read_file = open(self.in_file,"r")
        except IOError:
            sys.exit("The '%s' does not exist.\nStopping" % (self.in_file))

        self.stormy_uci = {} # key by UCI
        exit_early = 0

        # Read one line at a time and process
        for line in read_file:

            too_early = 0

            # Process line
            fnc = self.strip_read(line)

            # See if a center or empty center
            if fnc[0] == 0 or fnc[0] == -999:

                # See if passes extra search criteria
                if self.time_check:
                    # See if Season screen
                    if self.time_check[4] != -1:
                        test = self.mm2season[fnc[1]['MM']]
                        if self.time_check[4] not in test:
                            # Get another
                            continue
                    else:
                        # See if pass start/end requirements
                        bot = 4
                        top = 9
                        for tf in self.time_filter:
                            bot -= 1
                            top -= 1
                            if self.time_check[bot] > fnc[1][tf]:
                                # Read another line until reach start
                                too_early = 1
                                break
                            elif fnc[1][tf] > self.time_check[top]:
                                # Passed end
                                exit_early = 1
                                # Only stops time_filter loop
                                break
                        if too_early:
                            continue
                        if exit_early:
                            # Stop reading altoghter
                            break

                    # Skip place check as need to use these results for that

            if(fnc[0] == -888):
                # Return near_stormy keyed by primary center
                self.stormy_uci[fnc[1]] = fnc[5]

        read_file.close()

    def strip_read(self,line):
        """
        Reads parses a line from the read_file for the purpose of extracting
        certain info.
        """
        parts = line.split()
        flag = int(parts[0])
        
        #        print "Jimmy in strip_read"
        #        print parts
        #        print flag
        #        print self.just_center_table

        if flag > 0:
            # Unpack a center
            center_table = {'YYYY'         : int(parts[0]),
                            'MM'           : int(parts[1]),
                            'DD'           : int(parts[2]),
                            'HH'           : int(parts[3]),
                            'JD'           : int(parts[4]),
                            'CoLat'        : int(parts[5]),
                            'Lon'          : int(parts[6]),
                            'GridID'       : int(parts[7]),
                            'GridSLP'      : int(parts[8]),
                            'RegSLP'       : int(parts[9]),
                            'GridLAP'      : int(parts[10]),
                            'Flags'        : int(parts[11]),
                            'Intensity'    : int(parts[12]),
                            'Disimularity' : int(parts[13]),
                            'UCI'          : parts[14],
                            'USI'          : parts[15]
                            }
            if self.just_center_table:
                attribution_table = {'NGrids'             : 1,
                                     'Area'               : 1,
                                     'Depth'              : 1,
                                     'NearestCenterDist'  : 1,
                                     'NearestCenterAngle' : 1,
                                     'MinOuterEdgeDist'   : 1,
                                     'MaxOuterEdgeDist'   : 1,
                                     'AveOuterEdgeDist'   : 1
                                     }
            else:
                # Unpack attribution group
                attribution_table = {'NGrids'             : int(parts[16]),
                                     'Area'               : int(parts[17]),
                                     'Depth'              : int(parts[18]),
                                     'NearestCenterDist'  : int(parts[19]),
                                     'NearestCenterAngle' : int(parts[20]),
                                     'MinOuterEdgeDist'   : int(parts[21]),
                                     'MaxOuterEdgeDist'   : int(parts[22]),
                                     'AveOuterEdgeDist'   : int(parts[23])
                                     }

            # If needed extract and return attribution gridIDs
            if self.include_atts:
                natts = int(parts[16])
                atts = parts[24:23+natts]
                atts = [int(x) for x in atts]
            else:
                atts = []

            return (0,center_table,attribution_table,atts)

        elif(flag == -888):
            # Unpack near_stormy gridids
            skip = int(parts[2])
            jump = 2+skip+1
            hop  = jump + 2
            nstormy = int(parts[jump])
            stormy = parts[hop:hop+nstormy]
            stormy = [int(x) for x in stormy]
            if nstormy != len(stormy):
                print "Read Error Stormy",parts
                print nstormy,len(stormy),stormy
            return (-888,parts[1],int(parts[2]),parts[3],int(parts[4]),stormy)

        elif(flag == -777):
            # Unpack problematic gridids
            probs = [int(x) for x in parts[1:]]
            return ((-777,probs))

        elif(flag == -999):
            # Unpack empty centers
            center_table = {'YYYY'         : int(parts[1]),
                            'MM'           : int(parts[2]),
                            'DD'           : int(parts[3]),
                            'HH'           : int(parts[4]),
                            'JD'           : int(parts[5]),
                            'CoLat'        : int(parts[6]),
                            'Lon'          : int(parts[7]),
                            'GridID'       : int(parts[8]),
                            'GridSLP'      : int(parts[9]),
                            'RegSLP'       : int(parts[10]),
                            'GridLAP'      : int(parts[11]),
                            'Flags'        : int(parts[12]),
                            'Intensity'    : int(parts[13]),
                            'Disimularity' : int(parts[14]),
                            'UCI'          : parts[15],
                            'USI'          : parts[16]
                            }
            return (-999,center_table,[],[])

        else:
            sys.exit("Yikes! Unrecognized flag: %s" %(repr(flag)))

    def save_tracks(self):
        """Save detail_tracks dbase to out_file"""

        # Start file I/O
        print "JIMMY in save_tracks"
        print self.detail_tracks
        try:
            write_file = open(self.detail_tracks,"w")
        except IOError:
            warning = "Cannot create file '%s'.\nStopping"
            sys.exit(warning % (self.detail_tracks))

        tracks = self.sorted_tracks.keys()
        tracks.sort()
        for usi in tracks:
            uci = self.sorted_tracks[usi]
            write_file.write("%s" % (usi))
            for usi in uci:
                write_file.write(" %s" % (usi))
            write_file.write("\n")
        write_file.close()

    def dump_tracks(self):
        """Filter and save as tracks"""
        
        # Reset save_output
        self.save_output = self.save_output_original

        # Start file I/O
        read_file,write_file = self.start_IO()
        
        # JIMMY ADDED TO SORT THE TRACKS
        alltracks = self.track_holder
        sortedtracks = sorted(alltracks)
        # For some reason, it worked better to assign this later on
        # though it may have been a different error that was creating 
        # problems.  
        #        self.track_holder = sortedtracks
        track_counter = -1
        long_storm_count = -1
        # JIMMY ALL OF THE ABOVE IS NEW

        for usi in self.track_holder:
            track_counter = track_counter+1
            track_passed = 1 # Defaults to pass if no time_check needed

            # See if any center passes extra search criteria
            if self.time_check:
                for line in self.track_holder[usi]:
                    track_passed = 0 # set to fail
                    # Process UCI
                    fnc = self.strip_read(line)

                    # See if Season screen
                    if self.time_check[4] != -1:
                        test = self.mm2season[fnc[1]['MM']]
                        if self.time_check[4] not in test:
                            track_passed = 1
                            # If even one passes whole thing passes
                            break
                    else:
                        # See if pass start/end requirements
                        bot = 4
                        top = 9
                        for tf in self.time_filter:
                            bot -= 1
                            top -= 1
                            if (self.time_check[top] < 10000 or
                                self.time_check[bot] > 0):
                                track_passed = 1
                                # If even one passes whole thing passes
                                break

            if not self.place_check:
                track_passed = 1 # ensure writes if not tested

            if self.place_check and track_passed:
                track_passed = 0 # Reset to False
                for line in self.track_holder[usi]:
                    # Process UCI
                    fnc = self.strip_read(line)

                    # Add center
                    screen = [fnc[1]['GridID']]

                    if self.include_atts and fnc[3]:
                        screen.extend(fnc[3])

                    if self.include_stormy:
                        # Allow 'stormy' grids into place check to do this you
                        # need to pre-populate self.stormy_uci.
                        if fnc[1]['UCI'] in self.stormy_uci.keys():
                            screen.extend(self.stormy_uci[fnc[1]['UCI']])

                    # Check for intersection of place_passed and fnc[3]
                    place_passed = [x for x in screen if x in self.place_check]
                    if place_passed:
                       track_passed = 1
                       # If even one passes whole thing passes
                       break

            if track_passed:
                # JIMMY, test writing only the usi to file.
                #write_file.write(usi)
                #write_file.write(str(track_counter))
                #print usi
                #print self.track_holder[usi]
                #print track_counter
                #if track_counter > 10:
                #     sys.exit()

                usi2 = sortedtracks[track_counter]                
                # TEST THE LENGTH OF THE CENTER
                center_duration = 0
                for line in self.track_holder[usi2]:
                    center_duration = center_duration + 1
                
                if center_duration > 5:
                    # Passed all filters write line to file
                    long_storm_count = long_storm_count + 1
                    # JIMMY MOST OF THE ABOVE IS NEW
                    for line in self.track_holder[usi2]:
                        write_file.write(line)
                        #    write_file.write(usi)
                    # JIMMY, comment out -444 separator for matlab readable.    
                    # write_file.write("-444\n")
        write_file.close()
        read_file.close()
        # JIMMY: write the number of cyclones.
        print track_counter
        print long_storm_count

#---Start of main code block. This show how to use the above code
if __name__=='__main__':

    import pickle,sys

    # Create a log file?
    log = 0

    # --------------------------------------------------------------------------
    # Select options for this run.
    # --------------------------------------------------------------------------
    picks = {0 : "NCEP/NCAR Reanalysis 1",
             1 : "NCEP-DOE Reanalysis 2",
             2 : "JJ, FOR JJ",
             3 : "GFDL GCM",
             4 : "ERA-Interim Reanalysis"}
    #JIMMY
    pick = 2
    if pick not in picks:
        sys.exit("ERROR: pick not listed in picks.")

    # This next set of lines should be copied from setup_vX.py
    # Short names by which pick will be labeled.
    models = ["nra","nra2","jj","gfdl","erai"]
    try:
        model = models[pick]
    except:
        sys.exit("ERROR: pick not listed in models.")

    # Length of file ending to replace if using year_loop
    tails = ["_att.txt","_tracks.txt","_centers.txt","_dumped_centers.txt"]
    # JIMMY  must use _tracks.txt
    #    tail = tails[0]
    tail = tails[1]

    cut_tail = len(tail)

    # Flags
    #  tracks: track info included in file
    #  atts: attribute info included in file
    #
    # Note tweaked self.just_center_table: in mcms_read for center/track pre-att read
    # also watch detail_tracks names in template
    tracks = ""
    atts = ""
    if tail.find("tracks") != -1:
        tracks = 1
    if tail.find("att") != -1:
        atts = 1
    # Note atts files can contain track info so if you want
    # track statistics for an att file manually set tracks
    # to 1 here.
    #tracks = 1

    # --------------------------------------------------------------------------
    # Alter default behavior found in either defs_vX.py or setup_vX.py
    # --------------------------------------------------------------------------

    # This next set of lines should be copied from setup_vX.py
    # Full path to the root directory where pick specific output will be stored.
    # Note it's possible that all of these directories are identical.
    #    result_directories = ["/Volumes/scratch/output/","/Volumes/scratch/output/",
    #        "/Volumes/scratch/output/","/Volumes/scratch/output/",
    #        "/Volumes/scratch/output/"]
    # JIMMY
    result_directories = [" "," ",defines.out_folder,]

    try:
        result_directory = result_directories[pick]
        if not os.path.exists(result_directory):
            sys.exit("ERROR: result_directory not found.")
    except:
        sys.exit("ERROR: pick not listed in result_directories.")

    # Directory to be created for storing temporary pick specific files.
    shared_path = "%s%s_files/" % (result_directory,model)

    # The default behavior is to run over all the
    # years found by setup_vX.py. Here you can
    # elect to override this behavior.
    over_write_years = []
    #over_write_years = [2007,2008]

    # Get some definitions. Note must have run setup_vx.py already!
    sf_file = "%ss_dat.p" % (shared_path)
    try:
        fnc_out = pickle.load(open(sf_file, 'rb'))
        (im,jm,maxid,lats,lons,timestep,dx,dy,dlon,dlat,start_lat,start_lon,
                dlon_sq,dlat_sq,two_dlat,model_flag,eq_grid,tropical_n,tropical_s,
                bot,mid,top,row_start,row_end,tropical_n_alt,tropical_s_alt,
                bot_alt,top_alt,lon_shift,lat_flip,the_calendar,found_years,
                super_years,dim_lat,dim_lon,dim_time,var_lat,var_lon,var_time,
                var_slp,var_topo,var_land_sea_mask,file_seperator,no_topo,
                no_mask,slp_path,model,out_path,shared_path,lat_edges,lon_edges,
                land_gridids,troubled_centers, faux_grids) = fnc_out
        #
        # JIMMY, IN THE LINE ABOVE, I ADD ,faux_grids TO MATCH CENTER_FINDER CALL TO s_dat.p
        # Save memory
        del troubled_centers
        del lat_edges
        del lon_edges
        del fnc_out
    except:
        sys.exit("\n\tWARNING: Error reading or finding %s" % (sf_file))

    header = "mcms_%s_%04d" % (model,int(super_years[0]))
   
    in_file = "%s%s%s" % (out_path,header,tail)
    # JIMMY, verbose.
    #print header
    #print in_file   
    #print "len(sys.argv), and sys.argv"
    #print len(sys.argv)
    #print sys.argv

    if len(sys.argv) == 1:
        # Set definitions and instantiate read_mcms w/out a template
        what_do = {"model" : model,
                    "in_file" : in_file,
                    "out_file" : "",
                    # JIMMY                    "just_center_table" : False,
                    "just_center_table" : True,
                    # JIMMY                     "detail_tracks" : tracks,
                    "detail_tracks" : 'jimmy_tracks',
                    "as_tracks" : "",
                    "start_time" : "%04d MM DD HH SEASON" % (int(super_years[0])),
                    "end_time" : "%04d MM DD HH SEASON" % (int(super_years[0])),
                    "places" : ["GLOBAL"],
                    "include_atts" : atts,
                    "include_stormy" : atts,
                    "just_centers" : False,
                    "save_output" : False,
                    "overwrite" : True 
                    }
        # Pass in model definitions, if sf_file available this is simple.
        if model in ["nra","nra2"]:
            # For the NCAR/NCEP Reanalysis 1 and 2 these values are provided
            # and nothing need be done.
            pass
        else:
            # Provide values
            what_do["tropical_end"] = row_end[tropical_n_alt]
            what_do["tropical_start"] = row_start[tropical_s_alt]
            what_do["maxID"] = maxid
            what_do["land_gridids"] = list[land_gridids]
    else:
        # Use provided template
        template = sys.argv[1]
        # JIMMY  I added the part after the ,
        what_do = {"template":template, "model":'nra2'}
        
    # Parse definitions.
    readit = Read_MCMS(**what_do)


    # See if request something other than everything.
    readit.check_time()
    readit.check_place()

    if readit.include_stormy:
        # Need to read in_file to extract stormy gridids
        readit.fetch_stormy()

    # Read center file
    readit.fetch_centers()

    if readit.detail_tracks:
        # Issue Warning!
        if tail in tails[2:]:
            warning = ("WARNING: detail_tracks requires that",
                    "in_file contains tracked centers!")
            import sys; sys.exit(warning)
        # Save tracks dbase to out_file
        readit.save_tracks()

    if readit.as_tracks:
        readit.dump_tracks()
